// Copyright 1998-2018 Epic Games, Inc. All Rights Reserved.

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"

#define XAxisTexel 32
#define YAxisTexel 16
#define ZAxisTexel 32

#define MotorDataMaxCount 64

Texture3D<float> InXAxisTexture;  //texture for special dimension (x or y or z)
Texture3D<float> InYAxisTexture;  //texture for special dimension (x or y or z)
Texture3D<float> InZAxisTexture;  //texture for special dimension (x or y or z)

// FSphereMotorUniformData
// {
//     uint NumMotors;
//     float MaxVelocity;
//     float TexelsPerMeter;
//     float3 InPlayerWorldSpacePos;
//     float MotorRadius[MotorDataMaxCount];
//     float3 MotorWorldSpacePos[MotorDataMaxCount];
//     float3 MotorWindVelocity[MotorDataMaxCount];
// }
// FSphereMotorUniformData SphereMotorData;


RWTexture3D<float> OutXAxisTexture;
RWTexture3D<float> OutYAxisTexture;
RWTexture3D<float> OutZAxisTexture;

float LimitInMaxVelocity(float Velocity)
{
    return max(min(Velocity,SphereMotorData.MaxVelocity),-SphereMotorData.MaxVelocity);
}


void ModifyVelocityInTexture(uint3 GridPos,float3 WindVelocity)
{
    OutXAxisTexture[GridPos.xzy] =  SphereMotorData.MaxVelocity;//LimitInMaxVelocity(InXAxisTexture[GridPos.xzy] + WindVelocity.x);//InXAxisTexture[GridPos.xzy] + WindVelocity.x;
    OutYAxisTexture[GridPos.xzy] =  LimitInMaxVelocity(InYAxisTexture[GridPos.xzy] + WindVelocity.y);//InYAxisTexture[GridPos.xzy] + WindVelocity.y;
    OutZAxisTexture[GridPos.xzy] =  LimitInMaxVelocity(InZAxisTexture[GridPos.xzy] + WindVelocity.z);//InZAxisTexture[GridPos.xzy] + WindVelocity.z;
}

[numthreads(32,32,1)]
void MainCS(uint3 ThreadId : SV_DispatchThreadID)
{

    uint3 GridPlayerPos = uint3(XAxisTexel * 0.5f,YAxisTexel * 0.5f,ZAxisTexel * 0.5f);

    for(int y = 0; y < YAxisTexel;++y)
    {
        uint3 GridPos = uint3(ThreadId.x,y,ThreadId.y);
        
        for(int i = 0;i < SphereMotorData.NumMotors;++i)
        {
            float3 MotorPos = SphereMotorData.MotorWorldSpacePos[i];
            float3 Velocity = SphereMotorData.MotorWindVelocity[i];
            float Radius = SphereMotorData.MotorRadius[i];
            
            float3 GridMotorPos = (MotorPos - SphereMotorData.InPlayerWorldSpacePos) * SphereMotorData.TexelsPerMeter + GridPlayerPos;
            float3 WindVelocity = Velocity;
            float3 deltaPos = GridMotorPos - GridPos;
            
            if(length( deltaPos) < Radius * SphereMotorData.TexelsPerMeter)
            {
                ModifyVelocityInTexture(GridPos,WindVelocity);
            }
        }
    }
}