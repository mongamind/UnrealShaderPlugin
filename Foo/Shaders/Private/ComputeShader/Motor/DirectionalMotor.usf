// Copyright 1998-2018 Epic Games, Inc. All Rights Reserved.

/*=============================================================================
    LensDistortionUVGeneration.usf: Generate lens distortion and undistortion
    UV displacement map into a render target.

    The pixel shader directly compute the distort viewport UV to undistort
    viewport UV displacement using Sv_Position and the reference equations and
    store them into the red and green channels.

    However to avoid resolving with a ferrari method, or doing a newton method
    on the GPU to compute the undistort viewport UV to distort viewport UV
    displacement, this couple of shaders works as follow: The vertex shader
    undistort the grid's vertices, and pass down to the pixel shader the viewport
    UV of where they should have been on screen without undistortion. The pixel
    shader can then generate the undistort viewport UV to distort viewport UV
    displacement by just subtracting the pixel's viewport UV.
=============================================================================*/

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"

#define XAxisTexel 32
#define YAxisTexel 16
#define ZAxisTexel 32

#define MotorDataMaxCount 64

Texture3D<float> InXAxisTexture;  //texture for special dimension (x or y or z)
Texture3D<float> InYAxisTexture;  //texture for special dimension (x or y or z)
Texture3D<float> InZAxisTexture;  //texture for special dimension (x or y or z)

// float3 InPlayerWorldSpacePos;

// uint NumMotors;
// float3 MotorWorldSpacePos[MotorDataMaxCount];
// float3 MotorWindVelocity[MotorDataMaxCount];

// FMotorUniformData
// {
//     uint NumMotors;
//      float MaxVelocity;
//      float TexelsPerMeter;
//     float3 InPlayerWorldSpacePos;
//     float MotorRadius[MotorDataMaxCount];
//     float3 MotorWorldSpacePos[MotorDataMaxCount];
//     float3 MotorWindVelocity[MotorDataMaxCount];
// }
// FMotorUniformData MotorData;


RWTexture3D<float> OutXAxisTexture;
RWTexture3D<float> OutYAxisTexture;
RWTexture3D<float> OutZAxisTexture;

float LimitInMaxVelocity(float Velocity)
{
    return max(min(Velocity,MotorData.MaxVelocity),-MotorData.MaxVelocity);
}


void ModifyVelocityInTexture(uint3 GridPos,float3 WindVelocity)
{
    OutXAxisTexture[GridPos.xzy] =  MotorData.MaxVelocity;//LimitInMaxVelocity(InXAxisTexture[GridPos.xzy] + WindVelocity.x);//InXAxisTexture[GridPos.xzy] + WindVelocity.x;
    OutYAxisTexture[GridPos.xzy] =  LimitInMaxVelocity(InYAxisTexture[GridPos.xzy] + WindVelocity.y);//InYAxisTexture[GridPos.xzy] + WindVelocity.y;
    OutZAxisTexture[GridPos.xzy] =  LimitInMaxVelocity(InZAxisTexture[GridPos.xzy] + WindVelocity.z);//InZAxisTexture[GridPos.xzy] + WindVelocity.z;
}

[numthreads(32,32,1)]
void MainCS(uint3 ThreadId : SV_DispatchThreadID)
{

    uint3 GridPlayerPos = uint3(XAxisTexel * 0.5f,YAxisTexel * 0.5f,ZAxisTexel * 0.5f);

    for(int y = 0; y < YAxisTexel;++y)
    {
        uint3 GridPos = uint3(ThreadId.x,y,ThreadId.y);
        
        for(int i = 0;i < MotorData.NumMotors;++i)
        {
            float3 MotorPos = MotorData.MotorWorldSpacePos[i];
            float3 Velocity = MotorData.MotorWindVelocity[i];
            float Radius = MotorData.MotorRadius[i];
            
            float3 GridMotorPos = (MotorPos - MotorData.InPlayerWorldSpacePos) * MotorData.TexelsPerMeter + GridPlayerPos;
            float3 WindVelocity = Velocity;
            float3 deltaPos = GridMotorPos - GridPos;
            
            if(length( deltaPos) < Radius * MotorData.TexelsPerMeter)
            {
                ModifyVelocityInTexture(GridPos,WindVelocity);
            }
        }
    }
}